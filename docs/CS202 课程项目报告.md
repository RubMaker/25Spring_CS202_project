# CS202 课程项目报告

本报告为 2025 年春季南方科技大学计算机系课程 CS202 计算机组成原理的课程项目报告



## 团队分工

> Lab: 周三78节 王薇老师

| 学号     | 姓名   | 分工                         | 贡献比 |
| -------- | ------ | ---------------------------- | ------ |
| 12313023 | 黄思诚 | pipeline实现及相关汇编       | 33%    |
| 12312030 | 魏国新 | 单周期cpu实现以及差分测试    | 37%    |
| 12313519 | 李思陈 | 上板测试以及测试场景汇编编写 | 30%    |

## 计划日程安排和实施情况

| 时间      | 任务                                                   |
| --------- | ------------------------------------------------------ |
| 2025-4-23 | project启动                                            |
| 2025-4-23 | project整体规划和分工                                  |
| 2025-4-26 | 完成寄存器模块、立即数生成模块                         |
| 2025-5-2  | 完成常量文件Constants的编写                            |
| 2025-5-3  | 完成 ALU , BRU模块，pipeline完成EX模块                 |
| 2025-5-5  | 完成Controller模块，pipeline完成ID模块                 |
| 2025-5-11 | pipeline完成WB模块代码                                 |
| 2025-5-14 | 进行中期答辩                                           |
| 2025-5-18 | 完成Memory模块，pipeline完成IF, MEM模块代码            |
| 2025-5-21 | pipeline完成IF_ID, ID_EX等中间模块及hazard处理相关模块 |
| 2025-5-25 | pipeline完成缓存相关模块                               |
| 2025-5-31 | pipeline完成CPU模块                                    |
| 2025-6-2  | 完成上板测试                                           |
| 2025-6-6  | 完成报告                                               |

**以上计划均顺利按时完成** 

### ISA

参考 RISC-V 基本指令集 (RV32I) 及乘除法拓展 (RV32M)

| 指令                    | 指令类型 | 执行操作                                  |
| ----------------------- | -------- | ----------------------------------------- |
| `add rd, rs1, rs2`      | R        | rd = rs1 + rs2                            |
| `sub rd, rs1, rs2`      | R        | rd = rs1 - rs2                            |
| `xor rd, rs1, rs2`      | R        | rd = rs1 ^ rs2                            |
| `or rd, rs1, rs2`       | R        | rd = rs1 \| rs2                           |
| `and rd, rs1, rs2`      | R        | rd = rs1 & rs2                            |
| `sll rd, rs1, rs2`      | R        | rd = rs1 << rs2                           |
| `srl rd, rs1, rs2`      | R        | rd = rs1 >> rs2                           |
| `sra rd, rs1, rs2`      | R        | rd = rs1 >> rs2 (sign-extend)             |
| `slt rd, rs1, rs2`      | R        | rd = ( rs1 < rs2 ) ? 1 : 0                |
| `sltu rd, rs1, rs2`     | R        | rd = ( (u)rs1 < (u)rs2 ) ? 1 : 0          |
| `addi rd, rs1, rs2`     | I        | rd = rs1 + imm                            |
| `xori rd, rs1, rs2`     | I        | rd = rs1 ^ imm                            |
| `ori rd, rs1, rs2`      | I        | rd = rs1 \| imm                           |
| `andi rd, rs1, rs2`     | I        | rd = rs1 & imm                            |
| `slli rd, rs1, rs2`     | I        | rd = rs1 << imm[4:0]                      |
| `srli rd, rs1, rs2`     | I        | rd = rs1 >> imm[4:0]                      |
| `srai rd, rs1, rs2`     | I        | rd = rs1 >> imm[4:0] (sign-extend)        |
| `slti rd, rs1, rs2`     | I        | rd = (rs1 < imm) ? 1 : 0                  |
| `sltiu rd, rs1, rs2`    | I        | rd = ( (u)rs1 < (u)imm ) ? 1 : 0          |
| `lb rd, imm(rs1)`       | I        | 读取 1 byte 并做符号位扩展                |
| `lh rd, imm(rs1)`       | I        | 读取 1 half-word (2 bytes) 并做符号位扩展 |
| `lw rd, imm(rs1)`       | I        | 读取 1 word (4 bytes)                     |
| `lbu rd, imm(rs1)`      | I        | 读取 1 byte 并做 0 扩展                   |
| `lhu rd, imm(rs1)`      | I        | 读取 2 byte 并做 0 扩展                   |
| `sb rd, imm(rs1)`       | S        | 存入 1 byte                               |
| `sh rd, imm(rs1)`       | S        | 存入 1 half-word (2 bytes)                |
| `sw rd, imm(rs1)`       | S        | 存入 1 word (4 bytes)                     |
| `beq rs1, rs2, label`   | B        | if (rs1 == rs2)  pc += (imm << 1)         |
| `bne rs1, rs2, label`   | B        | if (rs1 != rs2)  pc += (imm << 1)         |
| `blt rs1, rs2, label`   | B        | if (rs1 < rs2)  pc += (imm << 1)          |
| `bge rs1, rs2, label`   | B        | if (rs1 >= rs2)  pc += (imm << 1)         |
| `bltu rs1, rs2, label`  | B        | if ( (u)rs1 < (u)rs2 )  pc += (imm << 1)  |
| `bgeu rs1, rs2, label`  | B        | if ( (u)rs1 >= (u)rs2 )  pc += (imm << 1) |
| `jal rd, label`         | J        | rd = pc + 4; pc += (imm << 1)             |
| `jalr rd, rs1, imm`     | I        | rd = pc + 4; pc = rs1 + imm               |
| `lui rd, imm`           | U        | rd = imm << 12                            |
| `auipc rd, imm`         | U        | rd = pc + (imm << 12)                     |
| `mul rd, rs1, rs2` *    | R        | rd = (rs1 * rs2)[31:0]                    |
| `mulh rd, rs1, rs2` *   | R        | rd = (rs1 * rs2)[63:32]                   |
| `mulhsu rd, rs1, rs2` * | R        | rd = (rs1 * (u)rs2)[63:32]                |
| `mulhu rd, rs1, rs2` *  | R        | rd = ( (u)rs1 * (u)rs2 )[63:32]           |
| `div rd, rs1, rs2` *    | R        | rd = rs1 / rs2                            |
| `rem rd, rs1, rs2` *    | R        | rd = rs1 % rs2                            |

## CPU架构设计说明

- **冯诺依曼架构**支持 **RISC-V** 指令集的CPU
- 含 32 个 32 bit 的寄存器 (不含 pc 寄存器)
- 寻址单位为 32 bit (4 byte)
- 栈空间基址为 0x7ffc
- **时钟频率:** 
  + CPU: 最高可支持 10MHz
  + MEM: 50MHz
  + VGA: 25MHz

### IO

- 使用 **MMIO** (Memory Mapping IO，内存映射) 进行 IO 操作并支持 UART
- 输入 (Input)
  - 1个按钮进行确认
  - 16个拨码开关（一组进行场景切换，一组输入测试数据）
- 输出 (Output)
  - 支持 16 个 LED 灯, 其中 8 个用于显示 CPU 状态
  - 8位数码管显示输出结果
  - VGA显示拨码开关读入数据

#### MMIO对应地址

| 地址       | 读/写 | 映射内容               | 取值范围 (省略前导0)    |
| :--------- | ----- | ---------------------- | ----------------------- |
| 0xFFFFFF00 | R     | 第 1 组拨码开关 (8 个) | 0x00 - 0xFF             |
| 0xFFFFFF04 | R     | 第 2 组拨码开关 (8 个) | 0x00 - 0xFF             |
| 0xFFFFFF08 | R     | 确认按钮               | 0x00 - 0x01             |
| 0xFFFFFF0C | W     | 第 1 组 LED (8 个)     | 0x00 - 0xFF             |
| 0xFFFFFF10 | W     | 第 2 组 LED (8 个)     | 0x00 - 0xFF             |
| 0xFFFFFF14 | W     | 数码管                 | 0x00000000 - 0xFFFFFFFF |
| 0xFFFFFF18 | W     | VGA                    | 0x00 - 0xFF             |

### CPU顶层接口

```verilog
module Top (
    // clk -> cpuclk, memclk, vgaclk
    input                     fpga_clk, reset_n,
    // uart related
    input  logic              rx,
    // interact with devices
    input  logic [`SWCH_WIDTH ] switches1, switches2,// switches3,
    input  logic              Button_Mid,
    input  logic              Button_Up,
    //input  logic [`KBPIN_WIDTH] kp, 
    output logic [`LED_WIDTH  ] led1_out, led2_out,// led3_out,
    //output logic [`LED_WIDTH  ] seg_en, seg_out,
    output logic [7:0] seg1,
               logic [7:0] seg2,
               logic [3:0] sel1,
               logic [3:0] sel2,
    // vga interface
    output logic              hsync,              // line synchronization signal
    output logic              vsync,              // vertical synchronization signal
    output logic [`COLOR_WIDTH] red,
    output logic [`COLOR_WIDTH] green,
    output logic [`COLOR_WIDTH] blue
);
```

单周期CPU 的输入信号包含：

- 一个 100MHz 的晶振时钟
- 高电平复位信号 rst
- UART 通信串口 rx
- 2 组拨码开关
- 1 个按钮（用来进行数据确认）

输出信号包含：

- 2 组 led 
- 数码管信号
- VGA信号

### CPU内部结构

#### ALU

```verilog
module ALU(
    input logic [`DATA_WIDTH] InputA,           // First operand
    input logic [`DATA_WIDTH] InputB,           // Second operand
    input logic [`ALUOP_WIDTH] AluOperation,        // ALU operation control
    output logic [`DATA_WIDTH] Result     // Result of operation
);
```

ALU模块进行数据运算，输入两个32bit的数据，根据AluOperation控制信号选择运算操作，输出结果也是32位的运算结果。

#### Branch unit

```verilog
module BRUSin(
    input logic [`DATA_WIDTH] Source1, Source2,  // Two source operands for comparison
    input logic [`DATA_WIDTH] Pc,               // Current instruction PC
    input logic [`DATA_WIDTH] Immediate,                // Immediate value (offset for branch)
    input logic [`BRUOP_WIDTH] BRUOperation,               // Branch operation code (controls comparison type)
    input logic              Jalr,                 // Jalr instruction flag (whether it is a register jump)
    input logic reset,
    output logic [`DATA_WIDTH ] NewPc               // Directly output the next instruction PC (no old PC needed for single-cycle)
);
```

用于处理分支指令的结果，在计算的下一条地址和Pc+4进行选择，可以理解为NextPc处理模块。

#### Constants

`Constants.vh`存储常数便于同意管理

#### Controller

```verilog
module Controller(
    /* verilator lint_off UNUSEDSIGNAL */
    input  logic [`DATA_WIDTH] Instruction,        // 32-bit Instructionuction input
    /* verilator lint_on UNUSEDSIGNAL */
    output logic JumpLink,
    output logic [`BRUOP_WIDTH] BranchOperation,  // Branch unit control
    output logic [`ALUOP_WIDTH] AluOperation,     // ALU control code
    // output logic [`ALUSRC_WIDTH] AluSourceSelector,       // ALU operand2 selector    //0 reg, 1 imm, 3 pc+imm, 4 special
    output logic AluSrc1, //0 rs1 1 pc
    output logic AluSrc2, //0 rs2 1 imm
    output logic [`LDST_WIDTH] MemoryOperation,     // Memory access type
    output logic MemWriteEn,                  // Memory write enable
    output logic MemReadEn,                  // Memory read enable
    output logic RegWriteEn,                  // Register write enable
    output logic [1:0] Mem2Reg,                 // Data memory to register flag
    input logic CpuStart
);
```

控制信号生成单元。输入 32 bit 的指令，输出若干控制信号，分别控制CPU各个模块的正常工作。

#### ImmGenerator

```verilog
module ImmGenerator(
    input logic [`DATA_WIDTH] Instruction,  // 32-bit input instruction
    output logic [`DATA_WIDTH] ImmData      // 32-bit generated immediate value
);
```

立即数生成模块，输入 32 bit 指令，根据指令类型生成符号扩展的 32 bit 立即数。

#### DataCache

```verilog
module DataCache (
    input  logic             clk, reset,
    // cpu interface
    input  logic [`DATA_WIDTH] Address,
    input  logic [`DATA_WIDTH] WriteData,
    input  logic [`LDST_WIDTH] MemOperation,
    input  logic             MemRead,
    input  logic             MemWrite,
    output logic [`DATA_WIDTH] DataOut,
    // mem interface
    input  logic [`DATA_WIDTH] MemData,
    output logic [`DATA_WIDTH] MemAddress,
    output logic [`DATA_WIDTH] MemWriteData,
    output logic             MemWriteEnB
);
```

此模块并未实现缓存功能，只是直接从内存读写数据，同时在此模块处理了L型指令对于不同位宽数据的读写（根据内存现有数据和需要读写的数据将输出数据扩展成32位的数据）

```verilog
module InstCache (
    input  logic             clk, reset,
    // cpu interface
    /* verilator lint_off UNUSEDSIGNAL */
    input  logic [`DATA_WIDTH] Address,
    /* verilator lint_on UNUSEDSIGNAL */
    output logic [`DATA_WIDTH] Instruction,
    // mem interface
    input  logic [`DATA_WIDTH] MemInstruction
    // output logic [`DATA_WIDTH] MemPc,
    // output logic uncached,
    // output logic hit
);
```

此模块并未实现缓存功能，只是直接从内存读取指令。

#### Memory

```verilog
module Memory(
    input logic reset,                          // Global reset signal (active high)
    input logic clkA, clkB,                     // Clock signals for port A and port B
    input logic [`DATA_WIDTH] AddressA, AddressB, // Address buses for port A and port B
    input logic [`DATA_WIDTH] WriteData,        // Write data for port B
    input logic EnableWriteB,                   // Write enable for port B (active high)
    input logic [`SWCH_WIDTH] Switch1, Switch2,  // Input switches (MMIO)
    input logic Button_Confirm,
    //input logic [`VGA_ADDRESS] VgaAddress,          // VGA display address (MMIO)
    output logic [`DATA_WIDTH] Seg1Out,          // 7-segment display output (MMIO)
    output logic [`LED_WIDTH] Led1Out, Led2Out,  // LED outputs (MMIO)
    output logic [`LED_WIDTH] VGA1Out,
    output logic [`DATA_WIDTH] ReadDataA,        // Read data output for port A
    output logic [`DATA_WIDTH] ReadDataB         // Read data output for port B
    // output logic IsMMIO,                     // Indicates if the address is MMIO
    // output logic IsExcept                     // Indicates if the address is an exception
);
```

内存模块，输入输出包含内存相关信号，IO 相关信号。 IO 采用轮询的 MMIO 模式。

#### PC

```verilog
module ProgramCounter(
    input clk,
    input reset,
    input logic [`DATA_WIDTH] PcInput,  // Input value of the program counter
    output logic [`DATA_WIDTH] PcOutput // Output value of the program counter
    );
```

Pc生成模块，根据branch unit模块产生的Pc值生成当前的Pc值。

#### RegisterFile

```verilog
module RegisterFile(
    input logic clk,//neg
    input logic reset,
    input logic [4:0] ReadRegAddr1,ReadRegAddr2,// support read from two Registers
    input logic [4:0] WriteRegAddr,// support write to one register
    input logic [`DATA_WIDTH] WriteData,// data to be written
    input logic RegWrite,
    output logic [`DATA_WIDTH] ReadData1,ReadData2// data read from Registers
    );
```

寄存器模块，输入包含时钟和复位信号，寄存器写入信号，和5 bit 位宽的读取寄存器的 rd1，rd2，写入寄存器的 WriteRegAddr。输出包含 32 bit 的从寄存器读取到的数据。

#### CPU_Clk

```verilog
module CPU_Clk (
    input clk,
    output clk0
);
```

对时钟信号进行手动分频，可以产生的时钟信号的范围更大（ IP Clocking Wizard 能够生成的时钟范围仅为 6MHz 到 80MHz）。

## Bonus 相关说明

### Pipeline

Pipeline采用**五级流水线**的结构，对hazard进行了处理同时引入了指令缓存 (ICache) 和数据缓存 (DCache)，涉及的模块如下

- Stage_IF, Stage_ID, Stage_EX, Stage_MEM, Stage_WB 为pipeline的五个阶段的模块
- IF_ID, ID_EX, EX_MEM, MEM_WB为中间寄存模块
- Hazard, Forward 为解决数据冒险的控制流水线前递和停顿的模块

- Branch_Predictor 为解决控制冒险的分支预测模块
- ICache、DCache 分别为指令和数据缓存，为提升与内存交互的效率的缓存模块

#### Hazard

```systemverilog
module Hazard (
    input  logic [`REGS_WID] IF_ID_rs1, IF_ID_rs2, ID_EX_rd,
    input  logic             ID_EX_MemRead,
    output logic             stall, IF_ID_Write, PC_Write  // 1 stall, 0 not stall
);
```

Hazard 模块用于判断是否存在因与内存交互而需停顿一个时钟周期的数据冒险，

判断逻辑为如果 `ID_EX_MemRead & ((ID_EX_rd == IF_ID_rs1) | (ID_EX_rd == IF_ID_rs2))` 成立，则需要停顿，其余情况无需停顿。

#### Forward

```systemverilog
module Forward (
    input  logic [`REGS_WID] ID_EX_rs1, ID_EX_rs2, EX_MEM_rd, MEM_WB_rd,
    input  logic             EX_MEM_RegWrite, MEM_WB_RegWrite,
    output logic [`FW_WID  ] fwA, fwB // 00: no fwd, 01: from MEM/WB, 10: from EX/MEM
);
```

前递模块，输入相关信号，输出是否前递的控制信号. 其中fwA和fwB分别控制ALU的src1和src2。以 ALU 的 src1 输入数据为例，src1 数据的前递选择器逻辑为，若 `EX_MEM_RegWrite & (EX_MEM_rd != 0) & (EX_MEM_rd == ID_EX_rs1)` 成立，那么将从 MEM 阶段前递数据，若 `MEM_WB_RegWrite & (MEM_WB_rd != 0) & ~(EX_MEM_RegWrite & (EX_MEM_rd != 0) & (EX_MEM_rd == ID_EX_rs1)) & (MEM_WB_rd == ID_EX_rs1)` 成立，将从 WB 阶段前递数据，其余情况均不需要前递。

Hazard处理部分测试代码如下:

```RISC-V
.text
    # Data hazard
    li t0, 300
    li t1, 200  
    addi t2, t1, 100       
    # Control hazard
    beq  t2, t0, branch

not_branch:
    add  t3, t1, t2        
    j    display   

branch:
    addi t3, t2, 5         

display:
    li   t4, 0xFFFFFF14  
    sw   t3, 0(t4)

```

预期的正确输出应为0x00000131,即十进制下的305

#### ICache

```systemverilog
module ICache #(
    parameter CACHE_WID = 4
)(
    input  logic             clk, rst,
    // cpu interface
    input  logic [`DATA_WID] addr,
    input  logic             predict_fail,
    output logic [`DATA_WID] inst,
    output logic             icache_stall,
    // mem interface
    input  logic [`DATA_WID] mem_inst,
    output logic [`DATA_WID] mem_pc
);
```

指令缓存模块用于管理指令的读取，缓存格式如下。 考虑到访问时延大，采用直接映射缓存，每个Block存储4 Words。如果 `tag` 不一样则缓存未命中(Cache Miss)，那么将流水线停顿并从内存中读取数据，输出并存入缓存。ICache停顿不会阻塞后续阶段的执行。

#### DCache

```systemverilog
module DCache #(
    parameter CACHE_WID = 4
)(
    input  logic             clk, rst,
    // cpu interface
    input  logic [`DATA_WID] addr,
    input  logic [`DATA_WID] write_data,
    input  logic [`LDST_WID] MEMOp,
    input  logic             MemRead,
    input  logic             MemWrite,
    output logic [`DATA_WID] data_out,
    output logic             dcache_stall,
    // mem interface
    input  logic [`DATA_WID] mem_data,
    output logic [`DATA_WID] mem_addr,
    output logic [`DATA_WID] mem_write_data,
    output logic             mem_web
);
```

数据缓存需注意一下 3 点：

- 数据缓存原理与指令缓存相似，但与内存的交互不仅限于读取，还包括写入
- 如果缓存未命中，则停顿整个流水线
- 若地址为 MMIO 相关，将无需经过缓存判断命中与停顿，直接与内存进行读取和写入
- 同时，由于寻址单位为 32 bit，`lb`, `lh`, `sb`, `sh` 等指令需对数据进行切片，数据缓存中也需要相应的处理这些情况



对于比较pipeline和单周期cpu的性能，采用了循环的方式，提供比较得到最终结果所需要的时间来评价性能，并根据输出结果来判断是否正确运行，测试代码如下：

```RISC-V
.text
    li   t0, 100000          
    li   t1, 0               

loop:
    add  t1, t1, t0         
    addi t0, t0, -1         
    bnez t0, loop          

    li   t2, 0xFFFFFF14     
    sw   t1, 0(t2)#0x2a06b550  
```

### auipc

auipc类型的指令首先在ID阶段被解码，如何生成控制信号供后续模块使用和处理

```
assign rd = inst[11:7];
```

```
`AUIPC_OPERATION: begin
                ALUOp    = `ALU_ADD;
                BRUOp    = `BRU_NOP;
                Jalr     = 0;
                ALUSrc   = 3;
                MemWrite = 0;
                MemRead  = 0;
                RegWrite = 1;
                MemtoReg = 0;
                MEMOp    = 0;
            end
```

然后EX阶段根据ALUSrc，将pc作为src1，imm作为src2，进入ALU进行加法操作，在后续将结果写入寄存器

```
assign src1 = ALU_src[1] ? pc : src1_mux;

	// source of ALU and write address
	always_comb begin  
		unique case (ALU_src)
			2'b00: src2 = src2_mux;
			2'b01: src2 = imm;
			2'b10: src2 = 4;
		    2'b11: src2 = imm;
		endcase
	end
```

测试场景为执行auipc并观察是否能够得到正确的结果。测试代码如下：

```
.text

    auipc t0, 1        
    addi  t0, t0, 32 

    li   t1, 0xFFFFFF14
    sw   t0, 0(t1)  
```

### 开源及AI的启发和帮助

在缓存设计时参考了网络中的缓存设计，这些代码为代码实现提供了参考和思路；在搭建CPU模块时使用AI根据子模块生成CPU模块，提高了效率。

但AI对信号间在各个模块间的传输存在错误，需要追踪信号并进行手动修改。

### Bonus 部分的问题及解决方案

+  指令 `auipc` 的实现。

  - **原因**: 指令 `auipc` 需要进行 pc 相关的计算，而 ALU 没有相关数据的输入
  - **解决方案**: 在 ALU 输入 rs1 的端口前添加选择器，对 pc 和 rs1_data 进行选择，同时拓宽控制信号 ALUSrc

+  缓存的实现。

  - **原因**: 只侧重于基本的缓存操作和状态机实现，缓存结构简单难以满足需求
  - **解决方案**: 使用脏位（dirty bit）来区分修改过的数据；针对特定地址（如 mmio）的未缓存访问做出了判断处理，确保对于特殊外设映射的访问不经过缓存；增加状态数进行更精细的管理

  